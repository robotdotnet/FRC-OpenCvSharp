def cppSetupModel = { project ->
    project.model {
        components {
            OpenCvSharpExtern(NativeLibrarySpec) {
                if (project.isArm) {
                    targetPlatform 'arm'
                } else {
                    if (!project.hasProperty('skipx86')) {
                        targetPlatform 'x86'
                    }
                    targetPlatform 'x64'
                }

                setupDefines(project, binaries)

                binaries.all {
                        project.setupDef(linker, "${rootDir}/OpenCVSharpExtern.def")
                    }


                sources {
                    cpp {
                        source {
                            srcDirs = [cppSrc]
                            includes = ["**/*.cpp"]
                        }
                        exportedHeaders {
                            srcDirs = [cppInclude, project.openCvInclude, "${rootDir}/include"]
                            includes = ['**/*.h']
                            includes = ['**/*.hpp']
                        }
                    }
                }
            }
        }
    }
}

def openCvZipTask = { project ->
    project.ext.opencvZip = project.tasks.create("${project.isArm ? 'arm' : 'native'}OpencvZip", Zip) {
        description = 'Creates platform-specific zip of the opencv libraries.'
        group = 'WPILib'
        destinationDir = project.buildDir
        baseName = 'OpenCvSharpExtern'
        if (project.isArm && project.hasProperty('compilerPrefix')
            && project.hasProperty('armSuffix')) {
            classifier = "${project.buildPlatform}${project.armSuffix}"
        } else {
            classifier = "${project.buildPlatform}"
        }
        duplicatesStrategy = 'exclude'

        project.model {
            binaries {
                withType(StaticLibraryBinarySpec) { binary ->
                    from(binary.staticLibraryFile) {
                        into getPlatformPath(binary)
                    }
                }
                withType(SharedLibraryBinarySpec) { binary ->
                    from(binary.sharedLibraryFile) {
                        into getPlatformPath(binary)
                    }
                    from (new File(binary.sharedLibraryFile.absolutePath + ".debug")) {
                        into getPlatformPath(binary)
                    }
                }
            }
        }
    }

    project.build.dependsOn project.opencvZip

    project.tasks.whenTaskAdded { task ->
        def name = task.name.toLowerCase()
        if (name.contains("sharedlibrary") || name.contains("staticlibrary")) {
            project.opencvZip.dependsOn task
        }
    }
}

def openCvStoreDepsTask = { project ->
    project.ext.depsZip = project.tasks.create("${project.isArm ? 'arm' : 'native'}depsZip") {
        if (project.isArm && !project.hasProperty("compilerPrefix")) {
            return
        }
        outputs.file(project.tasks.downloadWpiUtil.outputs.files.singleFile)
        outputs.file(project.tasks.downloadCsCore.outputs.files.singleFile)
    }
}

if (buildArm) {
    project(':arm') {
        apply plugin: 'cpp'

        apply from: "${rootDir}/toolchains/arm.gradle"

        project.debugStripSetup()
        cppSetupModel(project)
        openCvZipTask(project)
        useOpenCv(project)
        if (project.hasProperty("compilerPrefix")) {
            useWpiUtil(project)
            useCsCore(project)
        }
        openCvStoreDepsTask(project)
    }
}

if (buildNative) {
    project(':native') {
        apply plugin: 'cpp'

        apply from: "${rootDir}/toolchains/native.gradle"

        project.debugStripSetup()
        cppSetupModel(project)
        openCvZipTask(project)
        useOpenCv(project)
        useWpiUtil(project)
        useCsCore(project)
        openCvStoreDepsTask(project)
    }
}